<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ActRoot: BS::thread_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ActRoot
   </div>
   <div id="projectbrief">A set of powerful tools to analyze and simulate ACTAR TPC data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceBS.html">BS</a></li><li class="navelem"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBS_1_1thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BS::thread_pool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, and easy-to-use C++17 thread pool class.  
 <a href="classBS_1_1thread__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BS__thread__pool_8h_source.html">BS_thread_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool_1_1blocks.html">blocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to divide a range into blocks. Used by <code><a class="el" href="classBS_1_1thread__pool.html#ac4c3c82e37e3f691455e24a3b590f8bc" title="Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...">detach_blocks()</a></code>, <code><a class="el" href="classBS_1_1thread__pool.html#aff6d00a8f6ca2ab75a14845aa0d7bdd5" title="Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...">submit_blocks()</a></code>, <code><a class="el" href="classBS_1_1thread__pool.html#aeae8dd7a78eae115aa90181cd6fef13e" title="Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...">detach_loop()</a></code>, and <code><a class="el" href="classBS_1_1thread__pool.html#adbfa70de1b2e0bae92986002f6f3d161" title="Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...">submit_loop()</a></code>.  <a href="classBS_1_1thread__pool_1_1blocks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c6472571516f9b49eca3da136f85ad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">thread_pool</a> ()</td></tr>
<tr class="memdesc:a5c6472571516f9b49eca3da136f85ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool. The number of threads will be the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads.  <a href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">More...</a><br /></td></tr>
<tr class="separator:a5c6472571516f9b49eca3da136f85ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a04950b2056561f02d6ac48d0d71c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a82a04950b2056561f02d6ac48d0d71c2">thread_pool</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads)</td></tr>
<tr class="memdesc:a82a04950b2056561f02d6ac48d0d71c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads.  <a href="classBS_1_1thread__pool.html#a82a04950b2056561f02d6ac48d0d71c2">More...</a><br /></td></tr>
<tr class="separator:a82a04950b2056561f02d6ac48d0d71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52daef5d90c48e7170aaf45c7448b22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ae52daef5d90c48e7170aaf45c7448b22">thread_pool</a> (const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:ae52daef5d90c48e7170aaf45c7448b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified initialization function.  <a href="classBS_1_1thread__pool.html#ae52daef5d90c48e7170aaf45c7448b22">More...</a><br /></td></tr>
<tr class="separator:ae52daef5d90c48e7170aaf45c7448b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bbc2c2d583a6ffddde49ff056ec153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a11bbc2c2d583a6ffddde49ff056ec153">thread_pool</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads, const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a11bbc2c2d583a6ffddde49ff056ec153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads and initialization function.  <a href="classBS_1_1thread__pool.html#a11bbc2c2d583a6ffddde49ff056ec153">More...</a><br /></td></tr>
<tr class="separator:a11bbc2c2d583a6ffddde49ff056ec153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac11566157fc9fe4ab223d918e1d4cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a2ac11566157fc9fe4ab223d918e1d4cb">thread_pool</a> (const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="separator:a2ac11566157fc9fe4ab223d918e1d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47c0cf9939c57f816cfacf30f75253f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ad47c0cf9939c57f816cfacf30f75253f">thread_pool</a> (<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad47c0cf9939c57f816cfacf30f75253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97afce6a71c3090e1d2eed1e76387e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a97afce6a71c3090e1d2eed1e76387e17">operator=</a> (const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="separator:a97afce6a71c3090e1d2eed1e76387e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094463375442ab13be71ffe14c1f8a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a1094463375442ab13be71ffe14c1f8a6">operator=</a> (<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1094463375442ab13be71ffe14c1f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7cc32367d0d0c020bf103782506998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a1f7cc32367d0d0c020bf103782506998">~thread_pool</a> ()</td></tr>
<tr class="memdesc:a1f7cc32367d0d0c020bf103782506998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed.  <a href="classBS_1_1thread__pool.html#a1f7cc32367d0d0c020bf103782506998">More...</a><br /></td></tr>
<tr class="separator:a1f7cc32367d0d0c020bf103782506998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468">get_tasks_queued</a> () const</td></tr>
<tr class="memdesc:ab5faf242cb0eacbb5c1142a2bd966468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <a href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468">More...</a><br /></td></tr>
<tr class="separator:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">get_tasks_running</a> () const</td></tr>
<tr class="memdesc:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <a href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">More...</a><br /></td></tr>
<tr class="separator:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdec64ff8998d66017cc185ae397e064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064">get_tasks_total</a> () const</td></tr>
<tr class="memdesc:afdec64ff8998d66017cc185ae397e064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <code><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></code>.  <a href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064">More...</a><br /></td></tr>
<tr class="separator:afdec64ff8998d66017cc185ae397e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cb80839e30f218818e99af4d1dc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afe1cb80839e30f218818e99af4d1dc64">get_thread_count</a> () const</td></tr>
<tr class="memdesc:afe1cb80839e30f218818e99af4d1dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <a href="classBS_1_1thread__pool.html#afe1cb80839e30f218818e99af4d1dc64">More...</a><br /></td></tr>
<tr class="separator:afe1cb80839e30f218818e99af4d1dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f12fda255957ccba8521214f24c92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::thread::id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afa4f12fda255957ccba8521214f24c92">get_thread_ids</a> () const</td></tr>
<tr class="memdesc:afa4f12fda255957ccba8521214f24c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <code>std::thread::get_id()</code>.  <a href="classBS_1_1thread__pool.html#afa4f12fda255957ccba8521214f24c92">More...</a><br /></td></tr>
<tr class="separator:afa4f12fda255957ccba8521214f24c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b0b929324dad46b60a0321477ca352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ab7b0b929324dad46b60a0321477ca352">purge</a> ()</td></tr>
<tr class="memdesc:ab7b0b929324dad46b60a0321477ca352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all the tasks waiting in the queue. Tasks that are currently running will not be affected, but any tasks still waiting in the queue will be discarded, and will never be executed by the threads. Please note that there is no way to restore the purged tasks.  <a href="classBS_1_1thread__pool.html#ab7b0b929324dad46b60a0321477ca352">More...</a><br /></td></tr>
<tr class="separator:ab7b0b929324dad46b60a0321477ca352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a> (F &amp;&amp;task <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments and no return value into the task queue, with the specified priority. To push a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the task finishes executing, otherwise bad things will happen.  <a href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">More...</a><br /></td></tr>
<tr class="separator:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ac4c3c82e37e3f691455e24a3b590f8bc">detach_blocks</a> (const T first_index, const T index_after_last, F &amp;&amp;block, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <a href="classBS_1_1thread__pool.html#ac4c3c82e37e3f691455e24a3b590f8bc">More...</a><br /></td></tr>
<tr class="separator:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae8dd7a78eae115aa90181cd6fef13e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aeae8dd7a78eae115aa90181cd6fef13e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#aeae8dd7a78eae115aa90181cd6fef13e">detach_loop</a> (const T first_index, const T index_after_last, F &amp;&amp;loop, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:aeae8dd7a78eae115aa90181cd6fef13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <a href="classBS_1_1thread__pool.html#aeae8dd7a78eae115aa90181cd6fef13e">More...</a><br /></td></tr>
<tr class="separator:aeae8dd7a78eae115aa90181cd6fef13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdad3e793adf525ccc220444940a882"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6bdad3e793adf525ccc220444940a882"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a6bdad3e793adf525ccc220444940a882">detach_sequence</a> (const T first_index, const T index_after_last, F &amp;&amp;sequence <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:a6bdad3e793adf525ccc220444940a882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen.  <a href="classBS_1_1thread__pool.html#a6bdad3e793adf525ccc220444940a882">More...</a><br /></td></tr>
<tr class="separator:a6bdad3e793adf525ccc220444940a882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4172f1d76163c55e5d43e5835b23ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">reset</a> ()</td></tr>
<tr class="memdesc:a8b4172f1d76163c55e5d43e5835b23ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <a href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">More...</a><br /></td></tr>
<tr class="separator:a8b4172f1d76163c55e5d43e5835b23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a535346ea77b26da30a05a0f95a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a266a535346ea77b26da30a05a0f95a38">reset</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads)</td></tr>
<tr class="memdesc:a266a535346ea77b26da30a05a0f95a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <a href="classBS_1_1thread__pool.html#a266a535346ea77b26da30a05a0f95a38">More...</a><br /></td></tr>
<tr class="separator:a266a535346ea77b26da30a05a0f95a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bdb7f9cb1520779c1a71f8c3123d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a52bdb7f9cb1520779c1a71f8c3123d34">reset</a> (const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a52bdb7f9cb1520779c1a71f8c3123d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <a href="classBS_1_1thread__pool.html#a52bdb7f9cb1520779c1a71f8c3123d34">More...</a><br /></td></tr>
<tr class="separator:a52bdb7f9cb1520779c1a71f8c3123d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ebb337e3b7e4671352e4f3c67f7311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a45ebb337e3b7e4671352e4f3c67f7311">reset</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads, const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a45ebb337e3b7e4671352e4f3c67f7311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <a href="classBS_1_1thread__pool.html#a45ebb337e3b7e4671352e4f3c67f7311">More...</a><br /></td></tr>
<tr class="separator:a45ebb337e3b7e4671352e4f3c67f7311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a1cb20b4c0fa2b3fef18da2594d03"><td class="memTemplParams" colspan="2">template&lt;typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </td></tr>
<tr class="memitem:a735a1cb20b4c0fa2b3fef18da2594d03"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">submit_task</a> (F &amp;&amp;task <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:a735a1cb20b4c0fa2b3fef18da2594d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <code>std::future&lt;void&gt;</code> which can be used to wait until the task finishes.  <a href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">More...</a><br /></td></tr>
<tr class="separator:a735a1cb20b4c0fa2b3fef18da2594d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6d00a8f6ca2ab75a14845aa0d7bdd5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:aff6d00a8f6ca2ab75a14845aa0d7bdd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#aff6d00a8f6ca2ab75a14845aa0d7bdd5">submit_blocks</a> (const T first_index, const T index_after_last, F &amp;&amp;block, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:aff6d00a8f6ca2ab75a14845aa0d7bdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks.  <a href="classBS_1_1thread__pool.html#aff6d00a8f6ca2ab75a14845aa0d7bdd5">More...</a><br /></td></tr>
<tr class="separator:aff6d00a8f6ca2ab75a14845aa0d7bdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa70de1b2e0bae92986002f6f3d161"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:adbfa70de1b2e0bae92986002f6f3d161"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#adbfa70de1b2e0bae92986002f6f3d161">submit_loop</a> (const T first_index, const T index_after_last, F &amp;&amp;loop, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:adbfa70de1b2e0bae92986002f6f3d161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks.  <a href="classBS_1_1thread__pool.html#adbfa70de1b2e0bae92986002f6f3d161">More...</a><br /></td></tr>
<tr class="separator:adbfa70de1b2e0bae92986002f6f3d161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4378d957c3e5418e829c164affed2bfb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </td></tr>
<tr class="memitem:a4378d957c3e5418e829c164affed2bfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a4378d957c3e5418e829c164affed2bfb">submit_sequence</a> (const T first_index, const T index_after_last, F &amp;&amp;sequence <a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a>)</td></tr>
<tr class="memdesc:a4378d957c3e5418e829c164affed2bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the tasks.  <a href="classBS_1_1thread__pool.html#a4378d957c3e5418e829c164affed2bfb">More...</a><br /></td></tr>
<tr class="separator:a4378d957c3e5418e829c164affed2bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a0b066d078da097665ffadc475ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">wait</a> ()</td></tr>
<tr class="memdesc:a9e8a0b066d078da097665ffadc475ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <code><a class="el" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></code> instead, and call the <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> member function of the generated future.  <a href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">More...</a><br /></td></tr>
<tr class="separator:a9e8a0b066d078da097665ffadc475ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a4000155ecd7513b39093daaafc1d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:afc8a4000155ecd7513b39093daaafc1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afc8a4000155ecd7513b39093daaafc1d">wait_for</a> (const std::chrono::duration&lt; R, P &gt; &amp;duration)</td></tr>
<tr class="memdesc:afc8a4000155ecd7513b39093daaafc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified duration has passed.  <a href="classBS_1_1thread__pool.html#afc8a4000155ecd7513b39093daaafc1d">More...</a><br /></td></tr>
<tr class="separator:afc8a4000155ecd7513b39093daaafc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467e8c017965228950dacdbc73f0ae9c"><td class="memTemplParams" colspan="2">template&lt;typename C , typename D &gt; </td></tr>
<tr class="memitem:a467e8c017965228950dacdbc73f0ae9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a467e8c017965228950dacdbc73f0ae9c">wait_until</a> (const std::chrono::time_point&lt; C, D &gt; &amp;timeout_time)</td></tr>
<tr class="memdesc:a467e8c017965228950dacdbc73f0ae9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified time point has been reached.  <a href="classBS_1_1thread__pool.html#a467e8c017965228950dacdbc73f0ae9c">More...</a><br /></td></tr>
<tr class="separator:a467e8c017965228950dacdbc73f0ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1bc52c5ed9a0d1d867585e492b4c99a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a1bc52c5ed9a0d1d867585e492b4c99a2">create_threads</a> (const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a1bc52c5ed9a0d1d867585e492b4c99a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the threads in the pool and assign a worker to each thread.  <a href="classBS_1_1thread__pool.html#a1bc52c5ed9a0d1d867585e492b4c99a2">More...</a><br /></td></tr>
<tr class="separator:a1bc52c5ed9a0d1d867585e492b4c99a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4777cae9085a4fa792a334f1015d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a> ()</td></tr>
<tr class="memdesc:a97b4777cae9085a4fa792a334f1015d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the threads in the pool.  <a href="classBS_1_1thread__pool.html#a97b4777cae9085a4fa792a334f1015d6">More...</a><br /></td></tr>
<tr class="separator:a97b4777cae9085a4fa792a334f1015d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0449c4a34e857dc9f6fce504278bf9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af">worker</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> idx, const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a0449c4a34e857dc9f6fce504278bf9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker function to be assigned to each thread in the pool. Waits until it is notified by <code><a class="el" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7" title="Submit a function with no arguments and no return value into the task queue, with the specified prior...">detach_task()</a></code> that a task is available, and then retrieves the task from the queue and executes it. Once the task finishes, the worker notifies <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> in case it is waiting.  <a href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af">More...</a><br /></td></tr>
<tr class="separator:a0449c4a34e857dc9f6fce504278bf9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a0e408b669d10fef88539e52aae0f222c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">determine_thread_count</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads)</td></tr>
<tr class="memdesc:a0e408b669d10fef88539e52aae0f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many threads the pool should have, based on the parameter passed to the constructor or <a class="el" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef" title="Reset the pool with the total number of hardware threads available, as reported by the implementation...">reset()</a>.  <a href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">More...</a><br /></td></tr>
<tr class="separator:a0e408b669d10fef88539e52aae0f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a> = {}</td></tr>
<tr class="memdesc:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable to notify <code><a class="el" href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af" title="A worker function to be assigned to each thread in the pool. Waits until it is notified by detach_tas...">worker()</a></code> that a new task has become available.  <a href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">More...</a><br /></td></tr>
<tr class="separator:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b9508ed414f5f06e318dc89775485"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">tasks_done_cv</a> = {}</td></tr>
<tr class="memdesc:ac80b9508ed414f5f06e318dc89775485"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable to notify <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> that the tasks are done.  <a href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">More...</a><br /></td></tr>
<tr class="separator:ac80b9508ed414f5f06e318dc89775485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4757e864a90eaf2144a50c7cd761f"><td class="memItemLeft" align="right" valign="top">std::queue&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a> = {}</td></tr>
<tr class="memdesc:adcd4757e864a90eaf2144a50c7cd761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of tasks to be executed by the threads.  <a href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">More...</a><br /></td></tr>
<tr class="separator:adcd4757e864a90eaf2144a50c7cd761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059515108dff15d4e7cb01d0e3678733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> = 0</td></tr>
<tr class="memdesc:a059515108dff15d4e7cb01d0e3678733"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter for the total number of currently running tasks.  <a href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">More...</a><br /></td></tr>
<tr class="separator:a059515108dff15d4e7cb01d0e3678733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a> = {}</td></tr>
<tr class="memdesc:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to synchronize access to the task queue by different threads.  <a href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">More...</a><br /></td></tr>
<tr class="separator:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a83012732b16fce9fb87a6bc37a8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a> = 0</td></tr>
<tr class="memdesc:a19a83012732b16fce9fb87a6bc37a8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads in the pool.  <a href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">More...</a><br /></td></tr>
<tr class="separator:a19a83012732b16fce9fb87a6bc37a8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d390bd82d042e989baf9783bb424ae3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::thread[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a> = nullptr</td></tr>
<tr class="memdesc:a7d390bd82d042e989baf9783bb424ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to manage the memory allocated for the threads.  <a href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">More...</a><br /></td></tr>
<tr class="separator:a7d390bd82d042e989baf9783bb424ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3f9e45366bd2b6a66fdf1e15df9b40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = false</td></tr>
<tr class="memdesc:ada3f9e45366bd2b6a66fdf1e15df9b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating that <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> is active and expects to be notified whenever a task is done.  <a href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">More...</a><br /></td></tr>
<tr class="separator:ada3f9e45366bd2b6a66fdf1e15df9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031db7480dd2ff3d13a4ba3d0aec3bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">workers_running</a> = false</td></tr>
<tr class="memdesc:a031db7480dd2ff3d13a4ba3d0aec3bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating to the workers to keep running. When set to <code>false</code>, the workers terminate permanently.  <a href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">More...</a><br /></td></tr>
<tr class="separator:a031db7480dd2ff3d13a4ba3d0aec3bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A fast, lightweight, and easy-to-use C++17 thread pool class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5c6472571516f9b49eca3da136f85ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6472571516f9b49eca3da136f85ad5">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool. The number of threads will be the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;: <a class="code" href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">thread_pool</a>(0, [] {}) {}</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a5c6472571516f9b49eca3da136f85ad5"><div class="ttname"><a href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">BS::thread_pool::thread_pool</a></div><div class="ttdeci">thread_pool()</div><div class="ttdoc">Construct a new thread pool. The number of threads will be the total number of hardware threads avail...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:287</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a82a04950b2056561f02d6ac48d0d71c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a04950b2056561f02d6ac48d0d71c2">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;: <a class="code" href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">thread_pool</a>(num_threads, [] {}) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae52daef5d90c48e7170aaf45c7448b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52daef5d90c48e7170aaf45c7448b22">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified initialization function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;: <a class="code" href="classBS_1_1thread__pool.html#a5c6472571516f9b49eca3da136f85ad5">thread_pool</a>(0, init_task) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11bbc2c2d583a6ffddde49ff056ec153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bbc2c2d583a6ffddde49ff056ec153">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads and initialization function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                                                                       : <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>(<a class="code" href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">determine_thread_count</a>(num_threads)), <a class="code" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>(std::make_unique&lt;std::thread[]&gt;(<a class="code" href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">determine_thread_count</a>(num_threads)))</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a1bc52c5ed9a0d1d867585e492b4c99a2">create_threads</a>(init_task);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a0e408b669d10fef88539e52aae0f222c"><div class="ttname"><a href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">BS::thread_pool::determine_thread_count</a></div><div class="ttdeci">static concurrency_t determine_thread_count(const concurrency_t num_threads)</div><div class="ttdoc">Determine how many threads the pool should have, based on the parameter passed to the constructor or ...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:877</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a19a83012732b16fce9fb87a6bc37a8d4"><div class="ttname"><a href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">BS::thread_pool::thread_count</a></div><div class="ttdeci">concurrency_t thread_count</div><div class="ttdoc">The number of threads in the pool.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1123</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a1bc52c5ed9a0d1d867585e492b4c99a2"><div class="ttname"><a href="classBS_1_1thread__pool.html#a1bc52c5ed9a0d1d867585e492b4c99a2">BS::thread_pool::create_threads</a></div><div class="ttdeci">void create_threads(const std::function&lt; void()&gt; &amp;init_task)</div><div class="ttdoc">Create the threads in the pool and assign a worker to each thread.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:842</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a7d390bd82d042e989baf9783bb424ae3"><div class="ttname"><a href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">BS::thread_pool::threads</a></div><div class="ttdeci">std::unique_ptr&lt; std::thread[]&gt; threads</div><div class="ttdoc">A smart pointer to manage the memory allocated for the threads.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1128</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ac11566157fc9fe4ab223d918e1d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac11566157fc9fe4ab223d918e1d4cb">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad47c0cf9939c57f816cfacf30f75253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47c0cf9939c57f816cfacf30f75253f">&#9670;&nbsp;</a></span>thread_pool() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f7cc32367d0d0c020bf103782506998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7cc32367d0d0c020bf103782506998">&#9670;&nbsp;</a></span>~thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::~thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed. </p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">wait</a>();</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a>();</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a97b4777cae9085a4fa792a334f1015d6"><div class="ttname"><a href="classBS_1_1thread__pool.html#a97b4777cae9085a4fa792a334f1015d6">BS::thread_pool::destroy_threads</a></div><div class="ttdeci">void destroy_threads()</div><div class="ttdoc">Destroy the threads in the pool.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:858</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a9e8a0b066d078da097665ffadc475ae0"><div class="ttname"><a href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">BS::thread_pool::wait</a></div><div class="ttdeci">void wait()</div><div class="ttdoc">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:746</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1bc52c5ed9a0d1d867585e492b4c99a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc52c5ed9a0d1d867585e492b4c99a2">&#9670;&nbsp;</a></span>create_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::create_threads </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the threads in the pool and assign a worker to each thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    {</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;        {</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;            <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> = <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>;</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">workers_running</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        }</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> i = 0; i &lt; <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>; ++i)</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        {</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[i] = std::thread(&amp;<a class="code" href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af">thread_pool::worker</a>, <span class="keyword">this</span>, i, init_task);</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;        }</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a031db7480dd2ff3d13a4ba3d0aec3bc9"><div class="ttname"><a href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">BS::thread_pool::workers_running</a></div><div class="ttdeci">bool workers_running</div><div class="ttdoc">A flag indicating to the workers to keep running. When set to false, the workers terminate permanentl...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1138</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a0449c4a34e857dc9f6fce504278bf9af"><div class="ttname"><a href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af">BS::thread_pool::worker</a></div><div class="ttdeci">void worker(const concurrency_t idx, const std::function&lt; void()&gt; &amp;init_task)</div><div class="ttdoc">A worker function to be assigned to each thread in the pool. Waits until it is notified by detach_tas...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:892</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a059515108dff15d4e7cb01d0e3678733"><div class="ttname"><a href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">BS::thread_pool::tasks_running</a></div><div class="ttdeci">size_t tasks_running</div><div class="ttdoc">A counter for the total number of currently running tasks.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1113</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a5cf8504f1b1a651bc0a714a65a8817c5"><div class="ttname"><a href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">BS::thread_pool::tasks_mutex</a></div><div class="ttdeci">std::mutex tasks_mutex</div><div class="ttdoc">A mutex to synchronize access to the task queue by different threads.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1118</div></div>
<div class="ttc" id="anamespaceBS_html_a7bb1747ef283bd1349183c445ee89aaa"><div class="ttname"><a href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">BS::concurrency_t</a></div><div class="ttdeci">std::invoke_result_t&lt; decltype(std::thread::hardware_concurrency)&gt; concurrency_t</div><div class="ttdoc">A convenient shorthand for the type of std::thread::hardware_concurrency(). Should evaluate to unsign...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:49</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97b4777cae9085a4fa792a334f1015d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4777cae9085a4fa792a334f1015d6">&#9670;&nbsp;</a></span>destroy_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::destroy_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the threads in the pool. </p>
<div class="fragment"><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    {</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;        {</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;            <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">workers_running</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        }</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.notify_all();</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> i = 0; i &lt; <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>; ++i)</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        {</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[i].join();</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        }</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_aecb3be4acff4c3d14b95b2cbad6dad6e"><div class="ttname"><a href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">BS::thread_pool::task_available_cv</a></div><div class="ttdeci">std::condition_variable task_available_cv</div><div class="ttdoc">A condition variable to notify worker() that a new task has become available.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1094</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4c3c82e37e3f691455e24a3b590f8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c3c82e37e3f691455e24a3b590f8bc">&#9670;&nbsp;</a></span>detach_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_blocks </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;<a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <code>block(start, end)</code> should typically involve a loop of the form <code>for (T i = start; i &lt; end; ++i)</code>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    {</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keywordflow">if</span> (index_after_last &gt; first_index)</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        {</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            <span class="keyword">const</span> blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> blk = 0; blk &lt; blks.get_num_blocks(); ++blk)</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                <a class="code" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a>(</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                    [block = std::forward&lt;F&gt;(block), start = blks.start(blk), end = blks.end(blk)]</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                    {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                        block(start, end);</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                    } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>);</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    }</div>
<div class="ttc" id="aBS__thread__pool_8h_html_add1eb60128cc61076d614d32c0dc5271"><div class="ttname"><a href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a></div><div class="ttdeci">#define BS_THREAD_POOL_PRIORITY_OUTPUT</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:73</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><div class="ttname"><a href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">BS::thread_pool::detach_task</a></div><div class="ttdeci">void detach_task(F &amp;&amp;task BS_THREAD_POOL_PRIORITY_INPUT)</div><div class="ttdoc">Submit a function with no arguments and no return value into the task queue, with the specified prior...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:448</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeae8dd7a78eae115aa90181cd6fef13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae8dd7a78eae115aa90181cd6fef13e">&#9670;&nbsp;</a></span>detach_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;<a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">if</span> (index_after_last &gt; first_index)</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        {</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="keyword">const</span> blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> blk = 0; blk &lt; blks.get_num_blocks(); ++blk)</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                <a class="code" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a>(</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                    [loop = std::forward&lt;F&gt;(loop), start = blks.start(blk), end = blks.end(blk)]</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                    {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                        for (T i = start; i &lt; end; ++i)</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                            loop(i);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                    } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>);</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bdad3e793adf525ccc220444940a882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdad3e793adf525ccc220444940a882">&#9670;&nbsp;</a></span>detach_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_sequence </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;sequence&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    {</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        <span class="keywordflow">for</span> (T i = first_index; i &lt; index_after_last; ++i)</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a>(</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                [sequence = std::forward&lt;F&gt;(sequence), i]</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                    sequence(i);</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>);</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd1397ef0eaeeb370ae1e4a7ce7ab4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">&#9670;&nbsp;</a></span>detach_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;task&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments and no return value into the task queue, with the specified priority. To push a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the task finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        {</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.emplace(std::forward&lt;F&gt;(task) <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>);</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        }</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.notify_one();</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_adcd4757e864a90eaf2144a50c7cd761f"><div class="ttname"><a href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">BS::thread_pool::tasks</a></div><div class="ttdeci">std::queue&lt; std::function&lt; void()&gt; &gt; tasks</div><div class="ttdoc">A queue of tasks to be executed by the threads.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1107</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e408b669d10fef88539e52aae0f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e408b669d10fef88539e52aae0f222c">&#9670;&nbsp;</a></span>determine_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::determine_thread_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine how many threads the pool should have, based on the parameter passed to the constructor or <a class="el" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef" title="Reset the pool with the total number of hardware threads available, as reported by the implementation...">reset()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The parameter passed to the constructor or <code><a class="el" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef" title="Reset the pool with the total number of hardware threads available, as reported by the implementation...">reset()</a></code>. If the parameter is a positive number, then the pool will be created with this number of threads. If the parameter is non-positive, or a parameter was not supplied (in which case it will have the default value of 0), then the pool will be created with the total number of hardware threads available, as obtained from <code>std::thread::hardware_concurrency()</code>. If the latter returns zero for some reason, then the pool will be created with just one thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of threads to use for constructing the pool. </dd></dl>
<div class="fragment"><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;        <span class="keywordflow">if</span> (num_threads &gt; 0)</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            <span class="keywordflow">return</span> num_threads;</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <span class="keywordflow">if</span> (std::thread::hardware_concurrency() &gt; 0)</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="keywordflow">return</span> std::thread::hardware_concurrency();</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;        <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5faf242cb0eacbb5c1142a2bd966468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5faf242cb0eacbb5c1142a2bd966468">&#9670;&nbsp;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued tasks. </dd></dl>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.size();</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07b4d97e3a9e40e3228e2ed1f9a717cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b4d97e3a9e40e3228e2ed1f9a717cc">&#9670;&nbsp;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of running tasks. </dd></dl>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a>;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afdec64ff8998d66017cc185ae397e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdec64ff8998d66017cc185ae397e064">&#9670;&nbsp;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <code><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of tasks. </dd></dl>
<div class="fragment"><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> + <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.size();</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe1cb80839e30f218818e99af4d1dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cb80839e30f218818e99af4d1dc64">&#9670;&nbsp;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<div class="fragment"><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    {</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afa4f12fda255957ccba8521214f24c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4f12fda255957ccba8521214f24c92">&#9670;&nbsp;</a></span>get_thread_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::thread::id&gt; BS::thread_pool::get_thread_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <code>std::thread::get_id()</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique thread identifiers. </dd></dl>
<div class="fragment"><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        std::vector&lt;std::thread::id&gt; thread_ids(<a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> i = 0; i &lt; <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>; ++i)</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        {</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;            thread_ids[i] = <a class="code" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[i].get_id();</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        }</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keywordflow">return</span> thread_ids;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a97afce6a71c3090e1d2eed1e76387e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97afce6a71c3090e1d2eed1e76387e17">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a>&amp; BS::thread_pool::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1094463375442ab13be71ffe14c1f8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094463375442ab13be71ffe14c1f8a6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a>&amp; BS::thread_pool::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7b0b929324dad46b60a0321477ca352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b0b929324dad46b60a0321477ca352">&#9670;&nbsp;</a></span>purge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge all the tasks waiting in the queue. Tasks that are currently running will not be affected, but any tasks still waiting in the queue will be discarded, and will never be executed by the threads. Please note that there is no way to restore the purged tasks. </p>
<div class="fragment"><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    {</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">while</span> (!<a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.empty())</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.pop();</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b4172f1d76163c55e5d43e5835b23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4172f1d76163c55e5d43e5835b23ef">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with the total number of hardware threads available, as reported by the implementation. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<div class="fragment"><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">reset</a>(0, [] {});</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a8b4172f1d76163c55e5d43e5835b23ef"><div class="ttname"><a href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">BS::thread_pool::reset</a></div><div class="ttdeci">void reset()</div><div class="ttdoc">Reset the pool with the total number of hardware threads available, as reported by the implementation...</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:534</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a266a535346ea77b26da30a05a0f95a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a535346ea77b26da30a05a0f95a38">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">reset</a>(num_threads, [] {});</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a45ebb337e3b7e4671352e4f3c67f7311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ebb337e3b7e4671352e4f3c67f7311">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    {</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        std::unique_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_PAUSE</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> was_paused = paused;</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        paused = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        tasks_lock.unlock();</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">wait</a>();</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a>();</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a> = <a class="code" href="classBS_1_1thread__pool.html#a0e408b669d10fef88539e52aae0f222c">determine_thread_count</a>(num_threads);</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a7d390bd82d042e989baf9783bb424ae3">threads</a> = std::make_unique&lt;std::thread[]&gt;(<a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a1bc52c5ed9a0d1d867585e492b4c99a2">create_threads</a>(init_task);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        tasks_lock.lock();</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_PAUSE</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        paused = was_paused;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a52bdb7f9cb1520779c1a71f8c3123d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bdb7f9cb1520779c1a71f8c3123d34">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    {</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#a8b4172f1d76163c55e5d43e5835b23ef">reset</a>(0, init_task);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff6d00a8f6ca2ab75a14845aa0d7bdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6d00a8f6ca2ab75a14845aa0d7bdd5">&#9670;&nbsp;</a></span>submit_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt;R&gt; BS::thread_pool::submit_blocks </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;<a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function to loop through (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <code>block(start, end)</code> should typically involve a loop of the form <code>for (T i = start; i &lt; end; ++i)</code>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the blocks to finish. If the block function returns a value, the <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> can also be used to obtain the values returned by each block. </dd></dl>
<div class="fragment"><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    {</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="keywordflow">if</span> (index_after_last &gt; first_index)</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            <span class="keyword">const</span> blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            multi_future&lt;R&gt; future;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            future.reserve(blks.get_num_blocks());</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> blk = 0; blk &lt; blks.get_num_blocks(); ++blk)</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                future.push_back(<a class="code" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">submit_task</a>(</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                    [block = std::forward&lt;F&gt;(block), start = blks.start(blk), end = blks.end(blk)]</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                    {</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                        return block(start, end);</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                    } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>));</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            <span class="keywordflow">return</span> future;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        }</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_a735a1cb20b4c0fa2b3fef18da2594d03"><div class="ttname"><a href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">BS::thread_pool::submit_task</a></div><div class="ttdeci">std::future&lt; R &gt; submit_task(F &amp;&amp;task BS_THREAD_POOL_PRIORITY_INPUT)</div><div class="ttdoc">Submit a function with no arguments into the task queue, with the specified priority....</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:594</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adbfa70de1b2e0bae92986002f6f3d161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfa70de1b2e0bae92986002f6f3d161">&#9670;&nbsp;</a></span>submit_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt;void&gt; BS::thread_pool::submit_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;<a class="el" href="BS__thread__pool_8h.html#a85e398f94ec537284739a2b74817f530">BS_THREAD_POOL_PRIORITY_INPUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. It cannot have a return value. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the blocks to finish. </dd></dl>
<div class="fragment"><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    {</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        <span class="keywordflow">if</span> (index_after_last &gt; first_index)</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            <span class="keyword">const</span> blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code" href="classBS_1_1thread__pool.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            multi_future&lt;void&gt; future;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            future.reserve(blks.get_num_blocks());</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> blk = 0; blk &lt; blks.get_num_blocks(); ++blk)</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                future.push_back(<a class="code" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">submit_task</a>(</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                    [loop = std::forward&lt;F&gt;(loop), start = blks.start(blk), end = blks.end(blk)]</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                    {</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                        for (T i = start; i &lt; end; ++i)</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                            loop(i);</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                    } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>));</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            <span class="keywordflow">return</span> future;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        }</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;        <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4378d957c3e5418e829c164affed2bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4378d957c3e5418e829c164affed2bfb">&#9670;&nbsp;</a></span>submit_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt;R&gt; BS::thread_pool::submit_sequence </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;sequence&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the tasks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function used to define the sequence (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the tasks to finish. If the sequence function returns a value, the <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> can also be used to obtain the values returned by each task. </dd></dl>
<div class="fragment"><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        <span class="keywordflow">if</span> (index_after_last &gt; first_index)</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        {</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            multi_future&lt;R&gt; future;</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            future.reserve(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(index_after_last - first_index));</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            <span class="keywordflow">for</span> (T i = first_index; i &lt; index_after_last; ++i)</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                future.push_back(<a class="code" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03">submit_task</a>(</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                    [sequence = std::forward&lt;F&gt;(sequence), i]</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;                    {</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                        <span class="keywordflow">return</span> sequence(i);</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                    } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>));</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            <span class="keywordflow">return</span> future;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;        }</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;        <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a735a1cb20b4c0fa2b3fef18da2594d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735a1cb20b4c0fa2b3fef18da2594d03">&#9670;&nbsp;</a></span>submit_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;R&gt; BS::thread_pool::submit_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;task&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <code>std::future&lt;void&gt;</code> which can be used to wait until the task finishes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>
<div class="fragment"><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        <span class="keyword">const</span> std::shared_ptr&lt;std::promise&lt;R&gt;&gt; task_promise = std::make_shared&lt;std::promise&lt;R&gt;&gt;();</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a>(</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            [task = std::forward&lt;F&gt;(task), task_promise]</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;            {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                <span class="keywordflow">try</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                {</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                    <span class="keywordflow">if</span> constexpr (std::is_void_v&lt;R&gt;)</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                    {</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                        task();</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                        task_promise-&gt;set_value();</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                    }</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                    {</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                        task_promise-&gt;set_value(task());</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                    }</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                }</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                {</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                    <span class="keywordflow">try</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                    {</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                        task_promise-&gt;set_exception(std::current_exception());</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                    }</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                    <span class="keywordflow">catch</span> (...)</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                    {</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                    }</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                }</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;            } <a class="code" href="BS__thread__pool_8h.html#add1eb60128cc61076d614d32c0dc5271">BS_THREAD_POOL_PRIORITY_OUTPUT</a>);</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        <span class="keywordflow">return</span> task_promise-&gt;get_future();</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e8a0b066d078da097665ffadc475ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8a0b066d078da097665ffadc475ae0">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <code><a class="el" href="classBS_1_1thread__pool.html#a735a1cb20b4c0fa2b3fef18da2594d03" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></code> instead, and call the <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> member function of the generated future. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;wait_deadlock&lt;/tt&gt;</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;    {</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">this_thread::get_pool</a>() == <span class="keyword">this</span>)</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            <span class="keywordflow">throw</span> wait_deadlock();</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        std::unique_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">tasks_done_cv</a>.wait(tasks_lock,</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            [<span class="keyword">this</span>]</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                <span class="keywordflow">return</span> (<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> == 0) &amp;&amp; <a class="code" href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a>;</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            });</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    }</div>
<div class="ttc" id="aBS__thread__pool_8h_html_af65b31cabe5ec57c002c7e70aefe9b88"><div class="ttname"><a href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a></div><div class="ttdeci">#define BS_THREAD_POOL_PAUSED_OR_EMPTY</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:738</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_ac80b9508ed414f5f06e318dc89775485"><div class="ttname"><a href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">BS::thread_pool::tasks_done_cv</a></div><div class="ttdeci">std::condition_variable tasks_done_cv</div><div class="ttdoc">A condition variable to notify wait() that the tasks are done.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1099</div></div>
<div class="ttc" id="aclassBS_1_1thread__pool_html_ada3f9e45366bd2b6a66fdf1e15df9b40"><div class="ttname"><a href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">BS::thread_pool::waiting</a></div><div class="ttdeci">bool waiting</div><div class="ttdoc">A flag indicating that wait() is active and expects to be notified whenever a task is done.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:1133</div></div>
<div class="ttc" id="anamespaceBS_1_1this__thread_html_a503139b4a3d947c57861356ec527b409"><div class="ttname"><a href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">BS::this_thread::get_pool</a></div><div class="ttdeci">thread_local thread_info_pool get_pool</div><div class="ttdoc">A thread_local object used to obtain information about the thread pool that owns the current thread.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:148</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc8a4000155ecd7513b39093daaafc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a4000155ecd7513b39093daaafc1d">&#9670;&nbsp;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified duration has passed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An <code>std::ratio</code> representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tasks finished running, <code>false</code> if the duration expired but some tasks are still running.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;wait_deadlock&lt;/tt&gt;</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">this_thread::get_pool</a>() == <span class="keyword">this</span>)</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            <span class="keywordflow">throw</span> wait_deadlock();</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;        std::unique_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> status = <a class="code" href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">tasks_done_cv</a>.wait_for(tasks_lock, duration,</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            [<span class="keyword">this</span>]</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;            {</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                <span class="keywordflow">return</span> (<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> == 0) &amp;&amp; <a class="code" href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a>;</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;            });</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        <span class="keywordflow">return</span> status;</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a467e8c017965228950dacdbc73f0ae9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467e8c017965228950dacdbc73f0ae9c">&#9670;&nbsp;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; C, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified time point has been reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An <code>std::chrono::duration</code> type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tasks finished running, <code>false</code> if the time point was reached but some tasks are still running.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;wait_deadlock&lt;/tt&gt;</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    {</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">this_thread::get_pool</a>() == <span class="keyword">this</span>)</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;            <span class="keywordflow">throw</span> wait_deadlock();</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        std::unique_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> status = <a class="code" href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">tasks_done_cv</a>.wait_until(tasks_lock, timeout_time,</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;            [<span class="keyword">this</span>]</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;            {</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                <span class="keywordflow">return</span> (<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> == 0) &amp;&amp; <a class="code" href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a>;</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;            });</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;        <a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        <span class="keywordflow">return</span> status;</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0449c4a34e857dc9f6fce504278bf9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0449c4a34e857dc9f6fce504278bf9af">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::worker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A worker function to be assigned to each thread in the pool. Waits until it is notified by <code><a class="el" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7" title="Submit a function with no arguments and no return value into the task queue, with the specified prior...">detach_task()</a></code> that a task is available, and then retrieves the task from the queue and executes it. Once the task finishes, the worker notifies <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> in case it is waiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of this thread. </td></tr>
    <tr><td class="paramname">init_task</td><td>An initialization function to run in this thread before it starts to execute any submitted tasks. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    {</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        <a class="code" href="namespaceBS_1_1this__thread.html#ab8dc86ed7694ab35e56d11ee44a94484">this_thread::get_index</a>.<a class="code" href="classBS_1_1this__thread_1_1thread__info__index.html#a30059e0a06a182266ac5183baf3cec78">index</a> = idx;</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <a class="code" href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">this_thread::get_pool</a>.<a class="code" href="classBS_1_1this__thread_1_1thread__info__pool.html#af6d53f6aad3a8f564169b424db3023c9">pool</a> = <span class="keyword">this</span>;</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        init_task();</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        std::unique_lock tasks_lock(<a class="code" href="classBS_1_1thread__pool.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        {</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;            --<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a>;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;            tasks_lock.unlock();</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classBS_1_1thread__pool.html#ada3f9e45366bd2b6a66fdf1e15df9b40">waiting</a> &amp;&amp; (<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a> == 0) &amp;&amp; <a class="code" href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a>)</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                <a class="code" href="classBS_1_1thread__pool.html#ac80b9508ed414f5f06e318dc89775485">tasks_done_cv</a>.notify_all();</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;            tasks_lock.lock();</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;            <a class="code" href="classBS_1_1thread__pool.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.wait(tasks_lock,</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;                [<span class="keyword">this</span>]</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                {</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                    <span class="keywordflow">return</span> !<a class="code" href="BS__thread__pool_8h.html#af65b31cabe5ec57c002c7e70aefe9b88">BS_THREAD_POOL_PAUSED_OR_EMPTY</a> || !<a class="code" href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">workers_running</a>;</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                });</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classBS_1_1thread__pool.html#a031db7480dd2ff3d13a4ba3d0aec3bc9">workers_running</a>)</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;            {</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="preprocessor">#ifdef BS_THREAD_POOL_ENABLE_PRIORITY</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                <span class="keyword">const</span> std::function&lt;void()&gt; task = std::move(std::remove_const_t&lt;pr_task&amp;&gt;(<a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.top()).task);</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;                <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.pop();</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                <span class="keyword">const</span> std::function&lt;void()&gt; task = std::move(<a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.front());</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                <a class="code" href="classBS_1_1thread__pool.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.pop();</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                ++<a class="code" href="classBS_1_1thread__pool.html#a059515108dff15d4e7cb01d0e3678733">tasks_running</a>;</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;                tasks_lock.unlock();</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                task();</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            }</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            tasks_lock.lock();</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;        }</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        <a class="code" href="namespaceBS_1_1this__thread.html#ab8dc86ed7694ab35e56d11ee44a94484">this_thread::get_index</a>.<a class="code" href="classBS_1_1this__thread_1_1thread__info__index.html#a30059e0a06a182266ac5183baf3cec78">index</a> = std::nullopt;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        <a class="code" href="namespaceBS_1_1this__thread.html#a503139b4a3d947c57861356ec527b409">this_thread::get_pool</a>.<a class="code" href="classBS_1_1this__thread_1_1thread__info__pool.html#af6d53f6aad3a8f564169b424db3023c9">pool</a> = std::nullopt;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    }</div>
<div class="ttc" id="aclassBS_1_1this__thread_1_1thread__info__index_html_a30059e0a06a182266ac5183baf3cec78"><div class="ttname"><a href="classBS_1_1this__thread_1_1thread__info__index.html#a30059e0a06a182266ac5183baf3cec78">BS::this_thread::thread_info_index::index</a></div><div class="ttdeci">optional_index index</div><div class="ttdoc">The index of the current thread.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:112</div></div>
<div class="ttc" id="aclassBS_1_1this__thread_1_1thread__info__pool_html_af6d53f6aad3a8f564169b424db3023c9"><div class="ttname"><a href="classBS_1_1this__thread_1_1thread__info__pool.html#af6d53f6aad3a8f564169b424db3023c9">BS::this_thread::thread_info_pool::pool</a></div><div class="ttdeci">optional_pool pool</div><div class="ttdoc">A pointer to the thread pool that owns the current thread.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:137</div></div>
<div class="ttc" id="anamespaceBS_1_1this__thread_html_ab8dc86ed7694ab35e56d11ee44a94484"><div class="ttname"><a href="namespaceBS_1_1this__thread.html#ab8dc86ed7694ab35e56d11ee44a94484">BS::this_thread::get_index</a></div><div class="ttdeci">thread_local thread_info_index get_index</div><div class="ttdoc">A thread_local object used to obtain information about the index of the current thread.</div><div class="ttdef"><b>Definition:</b> BS_thread_pool.h:143</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aecb3be4acff4c3d14b95b2cbad6dad6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3be4acff4c3d14b95b2cbad6dad6e">&#9670;&nbsp;</a></span>task_available_cv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable BS::thread_pool::task_available_cv = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition variable to notify <code><a class="el" href="classBS_1_1thread__pool.html#a0449c4a34e857dc9f6fce504278bf9af" title="A worker function to be assigned to each thread in the pool. Waits until it is notified by detach_tas...">worker()</a></code> that a new task has become available. </p>

</div>
</div>
<a id="adcd4757e864a90eaf2144a50c7cd761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd4757e864a90eaf2144a50c7cd761f">&#9670;&nbsp;</a></span>tasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;std::function&lt;void()&gt; &gt; BS::thread_pool::tasks = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A queue of tasks to be executed by the threads. </p>

</div>
</div>
<a id="ac80b9508ed414f5f06e318dc89775485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80b9508ed414f5f06e318dc89775485">&#9670;&nbsp;</a></span>tasks_done_cv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable BS::thread_pool::tasks_done_cv = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition variable to notify <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> that the tasks are done. </p>

</div>
</div>
<a id="a5cf8504f1b1a651bc0a714a65a8817c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8504f1b1a651bc0a714a65a8817c5">&#9670;&nbsp;</a></span>tasks_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex BS::thread_pool::tasks_mutex = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutex to synchronize access to the task queue by different threads. </p>

</div>
</div>
<a id="a059515108dff15d4e7cb01d0e3678733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059515108dff15d4e7cb01d0e3678733">&#9670;&nbsp;</a></span>tasks_running</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::tasks_running = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A counter for the total number of currently running tasks. </p>

</div>
</div>
<a id="a19a83012732b16fce9fb87a6bc37a8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a83012732b16fce9fb87a6bc37a8d4">&#9670;&nbsp;</a></span>thread_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::thread_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of threads in the pool. </p>

</div>
</div>
<a id="a7d390bd82d042e989baf9783bb424ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d390bd82d042e989baf9783bb424ae3">&#9670;&nbsp;</a></span>threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::thread[]&gt; BS::thread_pool::threads = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A smart pointer to manage the memory allocated for the threads. </p>

</div>
</div>
<a id="ada3f9e45366bd2b6a66fdf1e15df9b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3f9e45366bd2b6a66fdf1e15df9b40">&#9670;&nbsp;</a></span>waiting</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::waiting = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag indicating that <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> is active and expects to be notified whenever a task is done. </p>

</div>
</div>
<a id="a031db7480dd2ff3d13a4ba3d0aec3bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031db7480dd2ff3d13a4ba3d0aec3bc9">&#9670;&nbsp;</a></span>workers_running</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::workers_running = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag indicating to the workers to keep running. When set to <code>false</code>, the workers terminate permanently. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Utility/inc/<a class="el" href="BS__thread__pool_8h_source.html">BS_thread_pool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
